package main

import (
	"fmt"
	"math/rand"
	"sync"
)

type gameOfLife struct {
	field     [][]cell
	iteration int
	fieldSize fieldSize
}
type position struct {
	row, col int
}

type fieldSize struct {
	width, height int
}

type cell string

const (
	alive cell = "x"
	dead  cell = "_"
)

type cellGenerator = func(position position) cell

var randomCellGenerator = func(position position) cell {
	if rand.Intn(2) == 1 {
		return alive
	}
	return dead
}

var deadCellGenerator = func(position position) cell {
	return dead
}

func main() {
	game := generateNewGame(fieldSize{width: 100, height: 20}, randomCellGenerator)
	untilIteration := 10
	for game.iteration <= untilIteration {
		printGame(game)
		game = game.advance()
	}
}

func printGame(game *gameOfLife) {
	fmt.Printf("Iteration: %d \n", game.iteration)
	for row := 0; row < game.fieldSize.height; row++ {
		fmt.Println(game.field[row])
	}
}

// generateNewGame returns a new gameOfLife with a field filled by a cellGenerator
func generateNewGame(fieldSize fieldSize, generator cellGenerator) *gameOfLife {
	field := initField(fieldSize, generator)
	return &gameOfLife{field: field, iteration: 0, fieldSize: fieldSize}
}

// initField returns a new field of the given size and filled with cells generated by a cellGenerator
func initField(size fieldSize, generator cellGenerator) [][]cell {
	field := make([][]cell, size.height)
	for row := 0; row < size.height; row++ {
		field[row] = make([]cell, size.width)
		for col := 0; col < size.width; col++ {
			field[row][col] = generator(position{row: row, col: col})
		}
	}
	return field
}

// advance returns a new gameOfLife with the advanced state for that new iteration.
func (game *gameOfLife) advance() *gameOfLife {
	advancedField := initField(game.fieldSize, deadCellGenerator)
	wg := new(sync.WaitGroup)
	wg.Add(game.fieldSize.height)
	for row := 0; row < game.fieldSize.height; row++ {
		go func(row int) {
			defer wg.Done()
			for col := 0; col < cap(advancedField[row]); col++ {
				advancedField[row][col] = game.calcAdvancedState(position{row: row, col: col})
			}
		}(row)
	}
	wg.Wait()
	return &gameOfLife{iteration: game.iteration + 1, field: advancedField, fieldSize: game.fieldSize}
}

// calcAdvancedState returns the cell that needs to be placed in the next iteration of the game at the given position row and col.
func (game *gameOfLife) calcAdvancedState(pos position) cell {
	isAlive := game.field[pos.row][pos.col] == alive
	aliveNeighbours := game.countAliveNeighbors(pos)
	if isAlive {
		if aliveNeighbours < 2 {
			return dead
		} else if aliveNeighbours > 3 {
			return dead
		}
		return alive
	} else {
		if aliveNeighbours == 3 {
			return alive
		}
		return dead
	}
}

// countAliveNeighbors counts the alive cells surrounding the given position. There can be at most 8 neighbours
func (game *gameOfLife) countAliveNeighbors(ownPosition position) int {
	aliveCounter := 0
	for rowOffset := -1; rowOffset <= 1; rowOffset++ {
		for colOffset := -1; colOffset <= 1; colOffset++ {
			positionToCheck := ownPosition.plus(rowOffset, colOffset)
			if positionToCheck == ownPosition {
				continue
			}
			if game.getOrDead(positionToCheck) == alive {
				aliveCounter++
			}
		}
	}
	return aliveCounter
}

// getOrDead returns the cell on the given position or a dead cell if it is out of bounds
func (game *gameOfLife) getOrDead(pos position) cell {
	if !pos.isOutOfBounds(game.fieldSize) {
		return game.field[pos.row][pos.col]
	}
	return dead
}

func (pos position) isOutOfBounds(fieldSize fieldSize) bool {
	return pos.row < 0 ||
		pos.row >= fieldSize.height ||
		pos.col < 0 ||
		pos.col >= fieldSize.width
}

func (pos position) plus(row, col int) position {
	return position{row: pos.row + row, col: pos.col + col}
}
