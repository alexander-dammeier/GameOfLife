package main

import (
	"fmt"
	"math/rand"
	"sync"
)

type gameOfLife struct {
	field     [][]cell
	iteration int
	fieldSize fieldSize
}

type position struct {
	x, y int
}

type fieldSize struct {
	width, height int
}

type cell string

const (
	alive cell = "x"
	dead  cell = "_"
)

type cellGenerator = func(position position) cell

var randomCellGenerator = func(position position) cell {
	if rand.Intn(2) == 1 {
		return alive
	}
	return dead
}

var deadCellGenerator = func(position position) cell {
	return dead
}

func main() {
	game := generateNewGame(fieldSize{width: 100, height: 20}, randomCellGenerator)
	untilIteration := 10
	for game.iteration <= untilIteration {
		printGame(game)
		game = game.advance()
	}
}

func printGame(game *gameOfLife) {
	fmt.Printf("Iteration: %d \n", game.iteration)
	for x := 0; x < game.fieldSize.height; x++ {
		fmt.Println(game.field[x])
	}
}

// generateNewGame returns a new gameOfLife with a field filled by a cellGenerator
func generateNewGame(fieldSize fieldSize, generator cellGenerator) *gameOfLife {
	field := initField(fieldSize, generator)
	return &gameOfLife{field: field, iteration: 0, fieldSize: fieldSize}
}

// initField returns a new field of the given size and filled with cells generated by a cellGenerator
func initField(size fieldSize, generator cellGenerator) [][]cell {
	field := make([][]cell, size.height)
	for x := 0; x < size.height; x++ {
		field[x] = make([]cell, size.width)
		for y := 0; y < size.width; y++ {
			field[x][y] = generator(position{x: x, y: y})
		}
	}
	return field
}

// advance returns a new gameOfLife with the advanced state for that new iteration.
func (game *gameOfLife) advance() *gameOfLife {
	advancedField := initField(game.fieldSize, deadCellGenerator)
	wg := new(sync.WaitGroup)
	wg.Add(game.fieldSize.height)
	for x := 0; x < game.fieldSize.height; x++ {
		go func(x int) {
			defer wg.Done()
			for y := 0; y < cap(advancedField[x]); y++ {
				advancedField[x][y] = game.calcAdvancedState(position{x: x, y: y})
			}
		}(x)
	}
	wg.Wait()
	return &gameOfLife{iteration: game.iteration + 1, field: advancedField, fieldSize: game.fieldSize}
}

// calcAdvancedState returns the cell that needs to be placed in the next iteration of the game at the given position x and y.
func (game *gameOfLife) calcAdvancedState(pos position) cell {
	isAlive := game.field[pos.x][pos.y] == alive
	aliveNeighbours := game.countAliveNeighbors(pos)
	if isAlive {
		if aliveNeighbours < 2 {
			return dead
		} else if aliveNeighbours > 3 {
			return dead
		}
		return alive
	} else {
		if aliveNeighbours == 3 {
			return alive
		}
		return dead
	}
}

// countAliveNeighbors counts the alive cells surrounding the given position. There can be at most 8 neighbours
func (game *gameOfLife) countAliveNeighbors(ownPosition position) int {
	aliveCounter := 0
	for verticalOffset := -1; verticalOffset <= 1; verticalOffset++ {
		for horizontalOffset := -1; horizontalOffset <= 1; horizontalOffset++ {
			positionToCheck := ownPosition.plus(verticalOffset, horizontalOffset)
			if positionToCheck == ownPosition {
				continue
			}
			if game.getOrDead(positionToCheck) == alive {
				aliveCounter++
			}
		}
	}
	return aliveCounter
}

// getOrDead returns the cell on the given position or a dead cell if it is out of bounds
func (game *gameOfLife) getOrDead(pos position) cell {
	if !pos.isOutOfBounds(game.fieldSize) {
		return game.field[pos.x][pos.y]
	}
	return dead
}

func (pos position) isOutOfBounds(fieldSize fieldSize) bool {
	return pos.x < 0 ||
		pos.x >= fieldSize.height ||
		pos.y < 0 ||
		pos.y >= fieldSize.width
}

func (pos position) plus(x, y int) position {
	return position{x: pos.x + x, y: pos.y + y}
}
